# Development Patterns

## Component Patterns

### Higher-Order Components (HOCs)
```tsx
/**
 * withAuth HOC for protecting components
 * 
 * @file src/hocs/withAuth.tsx
 * @description HOC that wraps components with authentication logic
 */
import { useAuth } from '@/hooks/useAuth';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';

export function withAuth<P extends object>(
  WrappedComponent: React.ComponentType<P>
) {
  return function AuthenticatedComponent(props: P) {
    const { isSignedIn, isLoading } = useAuth();
    const router = useRouter();

    useEffect(() => {
      if (!isLoading && !isSignedIn) {
        router.push('/sign-in');
      }
    }, [isSignedIn, isLoading, router]);

    if (isLoading) return <div>Loading...</div>;
    if (!isSignedIn) return null;

    return <WrappedComponent {...props} />;
  };
}
```

### Render Props Pattern
```tsx
/**
 * DataProvider component using render props
 * 
 * @file src/components/DataProvider.tsx
 * @description Component that provides data through render props
 */
interface DataProviderProps<T> {
  fetchFn: () => Promise<T>;
  children: (data: {
    data: T | null;
    loading: boolean;
    error: string | null;
    refetch: () => void;
  }) => React.ReactNode;
}

export function DataProvider<T>({ fetchFn, children }: DataProviderProps<T>) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const refetch = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const result = await fetchFn();
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setLoading(false);
    }
  }, [fetchFn]);

  useEffect(() => {
    refetch();
  }, [refetch]);

  return <>{children({ data, loading, error, refetch })}</>;
}
```

### Compound Components Pattern
```tsx
/**
 * Modal compound component
 * 
 * @file src/components/Modal.tsx
 * @description Modal component using compound component pattern
 */
interface ModalContextType {
  isOpen: boolean;
  onClose: () => void;
}

const ModalContext = createContext<ModalContextType | null>(null);

export function Modal({ children, isOpen, onClose }: ModalProps) {
  return (
    <ModalContext.Provider value={{ isOpen, onClose }}>
      {isOpen && (
        <div className="modal-overlay">
          <div className="modal-content">
            {children}
          </div>
        </div>
      )}
    </ModalContext.Provider>
  );
}

export function ModalHeader({ children }: { children: React.ReactNode }) {
  const context = useContext(ModalContext);
  if (!context) throw new Error('ModalHeader must be used within Modal');
  
  return <div className="modal-header">{children}</div>;
}

export function ModalBody({ children }: { children: React.ReactNode }) {
  return <div className="modal-body">{children}</div>;
}

export function ModalFooter({ children }: { children: React.ReactNode }) {
  return <div className="modal-footer">{children}</div>;
}
```

## State Management Patterns

### Context + Reducer Pattern
```tsx
/**
 * Global state management with Context and useReducer
 * 
 * @file src/contexts/AppContext.tsx
 * @description Global application state management
 */
interface AppState {
  user: User | null;
  theme: 'light' | 'dark';
  notifications: Notification[];
}

type AppAction =
  | { type: 'SET_USER'; payload: User | null }
  | { type: 'SET_THEME'; payload: 'light' | 'dark' }
  | { type: 'ADD_NOTIFICATION'; payload: Notification }
  | { type: 'REMOVE_NOTIFICATION'; payload: string };

const AppContext = createContext<{
  state: AppState;
  dispatch: React.Dispatch<AppAction>;
} | null>(null);

function appReducer(state: AppState, action: AppAction): AppState {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload };
    case 'SET_THEME':
      return { ...state, theme: action.payload };
    case 'ADD_NOTIFICATION':
      return { ...state, notifications: [...state.notifications, action.payload] };
    case 'REMOVE_NOTIFICATION':
      return {
        ...state,
        notifications: state.notifications.filter(n => n.id !== action.payload)
      };
    default:
      return state;
  }
}

export function AppProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(appReducer, {
    user: null,
    theme: 'light',
    notifications: []
  });

  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  );
}

export function useAppContext() {
  const context = useContext(AppContext);
  if (!context) throw new Error('useAppContext must be used within AppProvider');
  return context;
}
```

### Custom State Management Hook
```tsx
/**
 * Custom state management hook with persistence
 * 
 * @file src/hooks/usePersistedState.ts
 * @description State management with localStorage persistence
 */
export function usePersistedState<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((prev: T) => T)) => void] {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  const setValue = useCallback(
    (value: T | ((prev: T) => T)) => {
      try {
        const valueToStore = value instanceof Function ? value(storedValue) : value;
        setStoredValue(valueToStore);
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      } catch (error) {
        console.error(`Error setting localStorage key "${key}":`, error);
      }
    },
    [key, storedValue]
  );

  return [storedValue, setValue];
}
```

## API Patterns

### API Client Pattern
```tsx
/**
 * API Client with error handling and retry logic
 * 
 * @file src/lib/api-client.ts
 * @description Centralized API client with common functionality
 */
class ApiClient {
  private baseURL: string;
  private defaultHeaders: Record<string, string>;

  constructor(baseURL: string) {
    this.baseURL = baseURL;
    this.defaultHeaders = {
      'Content-Type': 'application/json',
    };
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.baseURL}${endpoint}`;
    const config: RequestInit = {
      ...options,
      headers: {
        ...this.defaultHeaders,
        ...options.headers,
      },
    };

    try {
      const response = await fetch(url, config);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error('API request failed:', error);
      throw error;
    }
  }

  async get<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: 'GET' });
  }

  async post<T>(endpoint: string, data: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  async put<T>(endpoint: string, data: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  }

  async delete<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: 'DELETE' });
  }
}

export const apiClient = new ApiClient(process.env.NEXT_PUBLIC_API_URL || '');
```

### Repository Pattern
```tsx
/**
 * User Repository for data access
 * 
 * @file src/repositories/UserRepository.ts
 * @description Repository pattern for user data access
 */
export class UserRepository {
  constructor(private apiClient: ApiClient) {}

  async findAll(params?: {
    page?: number;
    limit?: number;
    search?: string;
  }): Promise<{ users: User[]; total: number }> {
    const queryParams = new URLSearchParams();
    if (params?.page) queryParams.set('page', params.page.toString());
    if (params?.limit) queryParams.set('limit', params.limit.toString());
    if (params?.search) queryParams.set('search', params.search);

    return this.apiClient.get(`/users?${queryParams.toString()}`);
  }

  async findById(id: string): Promise<User> {
    return this.apiClient.get(`/users/${id}`);
  }

  async create(userData: CreateUserData): Promise<User> {
    return this.apiClient.post('/users', userData);
  }

  async update(id: string, userData: UpdateUserData): Promise<User> {
    return this.apiClient.put(`/users/${id}`, userData);
  }

  async delete(id: string): Promise<void> {
    return this.apiClient.delete(`/users/${id}`);
  }
}

export const userRepository = new UserRepository(apiClient);
```

## Error Handling Patterns

### Error Boundary Pattern
```tsx
/**
 * Error Boundary component
 * 
 * @file src/components/ErrorBoundary.tsx
 * @description Error boundary for catching and handling React errors
 */
interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<
  { children: React.ReactNode; fallback?: React.ComponentType<{ error: Error }> },
  ErrorBoundaryState
> {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
    // Log to error reporting service
  }

  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback || DefaultErrorFallback;
      return <FallbackComponent error={this.state.error!} />;
    }

    return this.props.children;
  }
}

function DefaultErrorFallback({ error }: { error: Error }) {
  return (
    <div className="error-boundary">
      <h2>Something went wrong</h2>
      <p>{error.message}</p>
      <button onClick={() => window.location.reload()}>
        Reload Page
      </button>
    </div>
  );
}
```

### Async Error Handling Pattern
```tsx
/**
 * Async error handling utility
 * 
 * @file src/utils/async-handler.ts
 * @description Utility for handling async operations with error handling
 */
export async function asyncHandler<T>(
  promise: Promise<T>
): Promise<[T | null, Error | null]> {
  try {
    const result = await promise;
    return [result, null];
  } catch (error) {
    return [null, error instanceof Error ? error : new Error(String(error))];
  }
}

// Usage example:
export async function fetchUserData(id: string) {
  const [user, error] = await asyncHandler(userRepository.findById(id));
  
  if (error) {
    console.error('Failed to fetch user:', error);
    return null;
  }
  
  return user;
}
```

## Performance Patterns

### Memoization Pattern
```tsx
/**
 * Memoized component with useMemo and useCallback
 * 
 * @file src/components/ExpensiveComponent.tsx
 * @description Component optimized with memoization
 */
interface ExpensiveComponentProps {
  data: ComplexData[];
  onItemClick: (id: string) => void;
  filter: string;
}

export const ExpensiveComponent = memo<ExpensiveComponentProps>(({
  data,
  onItemClick,
  filter
}) => {
  // Memoize expensive calculations
  const filteredData = useMemo(() => {
    return data.filter(item => 
      item.name.toLowerCase().includes(filter.toLowerCase())
    );
  }, [data, filter]);

  // Memoize callback functions
  const handleItemClick = useCallback((id: string) => {
    onItemClick(id);
  }, [onItemClick]);

  // Memoize expensive rendering
  const renderedItems = useMemo(() => {
    return filteredData.map(item => (
      <ExpensiveItem
        key={item.id}
        item={item}
        onClick={handleItemClick}
      />
    ));
  }, [filteredData, handleItemClick]);

  return (
    <div className="expensive-component">
      {renderedItems}
    </div>
  );
});
```

### Virtualization Pattern
```tsx
/**
 * Virtualized list component
 * 
 * @file src/components/VirtualizedList.tsx
 * @description Virtualized list for large datasets
 */
interface VirtualizedListProps<T> {
  items: T[];
  itemHeight: number;
  containerHeight: number;
  renderItem: (item: T, index: number) => React.ReactNode;
}

export function VirtualizedList<T>({
  items,
  itemHeight,
  containerHeight,
  renderItem
}: VirtualizedListProps<T>) {
  const [scrollTop, setScrollTop] = useState(0);
  
  const visibleStart = Math.floor(scrollTop / itemHeight);
  const visibleEnd = Math.min(
    visibleStart + Math.ceil(containerHeight / itemHeight) + 1,
    items.length
  );
  
  const visibleItems = items.slice(visibleStart, visibleEnd);
  const totalHeight = items.length * itemHeight;
  const offsetY = visibleStart * itemHeight;

  return (
    <div
      className="virtualized-list"
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div style={{ transform: `translateY(${offsetY}px)` }}>
          {visibleItems.map((item, index) => 
            renderItem(item, visibleStart + index)
          )}
        </div>
      </div>
    </div>
  );
}
```
